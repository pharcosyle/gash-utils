list  ::= sync
        | ('<sh-begin> sync ...)

sync  ::= exp
        | ('<sh-async> exp)

exp   ::= pipe
        | ('<sh-and> exp_1 exp_2)
        | ('<sh-or> exp_1 exp_2)
        | ('<sh-not> pipe)

pipe  ::= cmd*
        | ('<sh-pipeline> cmd* ...)

cmd*  ::= cmd
        | ('<sh-defun> name sync ...)

cmd   ::= ('<sh-exec> word ...)
        | ('<sh-exec-let> ((var var-word) ...) word ...)
        | ('<sh-with-redirects> (redir ...) [cmd])
        | ('<sh-set!> (var word) ...)
        | ('<sh-subshell> sync ...)
        | ('<sh-for> (name (word ...)) sync ...)
        | ('<sh-case> word ((pattern-word ...) sync ...) ...)
        | ('<sh-cond> (list sync ...) ... [('<sh-else> sync ...)])
        | ('<sh-while> list sync ...)
        | ('<sh-until> list sync ...)

redir ::= ('> fdes word)
        | ('< fdes word)
        | ('>& fdes word)
        | ('<& fdes word)
        | ('>> fdes word)
        | ('<> fdes word)
        | ('>! fdes word)
        | ('<< fdes word)
        ;; Internally, the parser also uses these two forms.
        | ('<< fdes ('<sh-here-end> qword))
        | ('<<- fdes ('<sh-here-end> qword))

word  ::= string
        | (word ...)
        | ('<sh-quote> word)
        | ('<sh-cmd-sub> [list] ...)
        | ('<sh-ref> var)
        | ('<sh-ref-or> var [word])
        | ('<sh-ref-or*> var [word])
        | ('<sh-ref-or!> var [word])
        | ('<sh-ref-or!*> var [word])
        | ('<sh-ref-assert> var [word])
        | ('<sh-ref-assert*> var [word])
        | ('<sh-ref-and> var [word])
        | ('<sh-ref-and*> var [word])
        | ('<sh-ref-except-min> var [word])
        | ('<sh-ref-except-max> var [word])
        | ('<sh-ref-skip-min> var [word])
        | ('<sh-ref-skip-max> var [word])
        | ('<sh-ref-length> var)

;; The parser never returns a qword, but it is a useful notion.  It
;; gets used internally by the parser and by the `word' module.
qword ::= string
        | (qword ...)
        | ('<sh-quote> qword)
